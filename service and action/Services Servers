
#include "ros/ros.h"
#include "std_srvs/Empty.h"
// Import the service message header file generated from the Empty.srv message

// We define the callback function of the service
bool my_callback(std_srvs::Empty::Request  &req,
                 std_srvs::Empty::Response &res)
{  
  // res.some_variable = req.some_variable + req.other_variable;
  ROS_INFO("My_callback has been called"); // We print an string whenever the Service gets called
  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "service_server");
  ros::NodeHandle nh;

  ros::ServiceServer my_service = nh.advertiseService("/my_service", my_callback); // create the Service called                                                                                          // my_service with the defined                                                                                        // callback
  ros::spin(); // mantain the service open.

  return 0;
}



________________________________________________________________________________________________________________
________________________________________________________________________________________________________________
________________________________________________________________________________________________________________





#include "my_custom_srv_msg_pkg/MyCustomServiceMessage.h"
#include "ros/ros.h"

bool my_callback(my_custom_srv_msg_pkg::MyCustomServiceMessage::Request &req,
                 my_custom_srv_msg_pkg::MyCustomServiceMessage::Response &res) {
  ROS_INFO("Request Data==> duration=%d", req.duration);
  if (req.duration > 5) {
    res.success = true;
    ROS_INFO("sending back response:true");
  } else {
    res.success = false;
    ROS_INFO("sending back response:false");
  }

  return true;
}

int main(int argc, char **argv) {
  ros::init(argc, argv, "service_server");
  ros::NodeHandle nh;

  ros::ServiceServer my_service =
      nh.advertiseService("/my_service", my_callback);
  ros::spin();

  return 0;
}

________________________________________________________________________________________________________________
________________________________________________________________________________________________________________
________________________________________________________________________________________________________________


#include "ros/ros.h"
#include "std_srvs/Empty.h"
#include "geometry_msgs/Twist.h"

ros::Publisher vel_pub;
geometry_msgs::Twist vel_msg;

bool my_callback(std_srvs::Empty::Request  &req,
                 std_srvs::Empty::Response &res)
{  
  ROS_INFO("The Service move_bb8_in_circle has been called");
  vel_msg.linear.x = 0.2;
  vel_msg.angular.z = 0.2;
  vel_pub.publish(vel_msg);
  ROS_INFO("Finished service move_bb8_in_circle");
  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "service_move_bb8_in_circle_server");
  ros::NodeHandle nh;

  ros::ServiceServer my_service = nh.advertiseService("/move_bb8_in_circle", my_callback);
  vel_pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 1000);
  ROS_INFO("Service /move_bb8_in_circle_custom Ready");
  ros::spin();

  return 0;
}





#include "ros/ros.h"
#include "std_srvs/Empty.h" 

int main(int argc, char **argv)
{
  ros::init(argc, argv, "service_move_bb8_in_circle_client"); // Initialise a ROS node
  ros::NodeHandle nh;
  
  // Create the connection to the service /move_bb8_in_circle
  ros::ServiceClient move_bb8_in_circle_service_client = nh.serviceClient<std_srvs::Empty>("/move_bb8_in_circle");
  std_srvs::Empty srv; // Create an object of type Empty
  
  if (move_bb8_in_circle_service_client.call(srv)) 
  {
    ROS_INFO("Service successfully called. Moving BB8 in a circle.");
  }
  else
  {
    ROS_ERROR("Failed to call service /move_bb8_in_circle");
    return 1;
  }

  return 0;
}


________________________________________________________________________________________________________________
________________________________________________________________________________________________________________
________________________________________________________________________________________________________________


#include "ros/ros.h"
#include "services_quiz/BB8CustomServiceMessage.h"
#include "geometry_msgs/Twist.h"

geometry_msgs::Twist vel;
ros::Publisher vel_pub;

bool my_callback(services_quiz::BB8CustomServiceMessage::Request &req, 
                 services_quiz::BB8CustomServiceMessage::Response &res) {
     
    ROS_INFO("The Service move_bb8_in_circle has been called with param repetitions - %i, side - %f", req.repetitions, req.side);

    if (req.repetitions > 0 && req.side > 0.0) {

        for (int i = 0; i < req.repetitions ; i++){
            for(int j = 0; j < 4; j++){
                ROS_INFO("step 1");
                vel.angular.z = 0.0;
                vel.linear.x = 0.5*req.side;

                ROS_INFO("step 2");
                vel_pub.publish(vel);
                ROS_INFO("step 3");

                ros::Duration(3).sleep();

                ROS_INFO("step 4");
                vel.linear.x = 0.0;
                vel.angular.z = 0.6;

                ROS_INFO("step 5");
                vel_pub.publish(vel);

                ROS_INFO("step 6");
                ros::Duration(3).sleep();
            }
        }

        vel.linear.x = 0.0;
        vel.angular.z = 0.0;
        vel_pub.publish(vel);

        ROS_INFO("Finished service move_bb8_in_circle");
        res.success = true;
        ROS_INFO("sending back response:true");

    } else {
        res.success = false;
        ROS_INFO("sending back response:false");
    }

    return true;
}

int main(int argc, char **argv) {
  ros::init(argc, argv, "service_server");
  ros::NodeHandle nh;

  ros::ServiceServer my_service = nh.advertiseService("/move_bb8_in_square_custom", my_callback);
  vel_pub = nh.advertise<geometry_msgs::Twist>("cmd_vel", 1000);
  ros::spin();

  return 0;
}


________________________________________________________________________________________________________________
________________________________________________________________________________________________________________
________________________________________________________________________________________________________________


#include "ros/ros.h"
#include "services_quiz/BB8CustomServiceMessage.h"
// Import the service message used by the service /move_bb8_in_circle_custom

int main(int argc, char **argv)
{
  ros::init(argc, argv, "call_bb8_move_custom_service_server"); // Initialise a ROS node with the name service_client
  ros::NodeHandle nh;

  // Create the connection to the service /move_bb8_in_circle_custom
  ros::service::waitForService("/move_bb8_in_square_custom");  // wait for service to be running
  ros::ServiceClient call_bb8_move_custom_service_server = nh.serviceClient<services_quiz::BB8CustomServiceMessage>("/move_bb8_in_square_custom");

  services_quiz::BB8CustomServiceMessage srv; // Create an object of type Empty

  srv.request.side = 2;
  srv.request.repetitions = 2;

  if (call_bb8_move_custom_service_server.call(srv)) // Send through the connection the name of the trajectory to execute
  {
    ROS_INFO("Service successfully called. Moving BB8 in a circle.");
  }
  else
  {
    ROS_ERROR("Failed to call service /move_bb8_in_circle_custom");
    return 1;
  }

  srv.request.side = 4;
  srv.request.repetitions = 1;

 if (call_bb8_move_custom_service_server.call(srv)) // Send through the connection the name of the trajectory to execute
  {
    ROS_INFO("Service successfully called. Moving BB8 in a circle.");
  }
  else
  {
    ROS_ERROR("Failed to call service /move_bb8_in_circle_custom");
    return 1;
  }

  return 0;
}

